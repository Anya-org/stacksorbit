#!/usr/bin/env python3
"""
Enhanced Conxian Deployment Script with CLI Integration
Provides comprehensive deployment and monitoring capabilities for the Conxian protocol
"""

import os
import sys
import json
import time
import subprocess
import requests
import yaml
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from datetime import datetime
import argparse

# Enhanced imports for monitoring
try:
    import psutil
    PSUTIL_AVAILABLE = True
except ImportError:
    PSUTIL_AVAILABLE = False

try:
    import colorama
    from colorama import Fore, Style
    colorama.init()
    COLORAMA_AVAILABLE = True
except ImportError:
    COLORAMA_AVAILABLE = False

class EnhancedConfigManager:
    """Enhanced configuration manager with persistence and validation"""

    def __init__(self, config_path: str = ".env"):
        self.config_path = Path(config_path)
        self.config = {}
        self.deployment_history = []

    def load_config(self) -> Dict:
        """Load configuration from .env file"""
        if not self.config_path.exists():
            self._create_default_config()

        with open(self.config_path, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    self.config[key.strip()] = value.strip().strip('"')

        return self.config

    def _create_default_config(self):
        """Create default configuration file"""
        default_config = """# Enhanced StacksOrbit Configuration for Conxian
# Generated by Enhanced CLI

# Required Variables
DEPLOYER_PRIVKEY=your_private_key_here
SYSTEM_ADDRESS=your_stacks_address_here
NETWORK=testnet

# Optional Variables (Recommended)
HIRO_API_KEY=your_hiro_api_key
CORE_API_URL=https://api.testnet.hiro.so
STACKS_API_BASE=https://api.testnet.hiro.so

# Deployment Configuration
DEPLOYMENT_MODE=full
BATCH_SIZE=5
PARALLEL_DEPLOY=false
CONTRACT_FILTER=

# Monitoring Configuration
MONITORING_ENABLED=true
LOG_LEVEL=INFO
SAVE_LOGS=true

# Security
VALIDATE_TRANSACTIONS=true
CONFIRMATION_TIMEOUT=300
"""

        self.config_path.parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w') as f:
            f.write(default_config)

    def save_config(self, config: Dict):
        """Save configuration to file"""
        with open(self.config_path, 'w') as f:
            for key, value in config.items():
                f.write(f"{key}={value}\n")

    def validate_config(self) -> Tuple[bool, List[str]]:
        """Validate configuration and return (is_valid, errors)"""
        errors = []

        required = ['DEPLOYER_PRIVKEY', 'SYSTEM_ADDRESS', 'NETWORK']
        for req in required:
            if req not in self.config or not self.config[req]:
                errors.append(f"Missing required configuration: {req}")

        # Validate private key format
        if 'DEPLOYER_PRIVKEY' in self.config:
            if not self._validate_private_key(self.config['DEPLOYER_PRIVKEY']):
                errors.append("Invalid DEPLOYER_PRIVKEY format")

        # Validate address format
        if 'SYSTEM_ADDRESS' in self.config:
            if not self._validate_address(self.config['SYSTEM_ADDRESS']):
                errors.append("Invalid SYSTEM_ADDRESS format")

        # Validate network
        if 'NETWORK' in self.config:
            if self.config['NETWORK'] not in ['devnet', 'testnet', 'mainnet']:
                errors.append("Invalid NETWORK. Must be devnet, testnet, or mainnet")

        return len(errors) == 0, errors

    def _validate_private_key(self, privkey: str) -> bool:
        """Validate private key format"""
        return len(privkey) == 64 and all(c in '0123456789abcdefABCDEF' for c in privkey)

    def _validate_address(self, address: str) -> bool:
        """Validate Stacks address format"""
        return address.startswith('S') and len(address) == 41

class ConxianHiroMonitor:
    """Enhanced monitoring using Hiro API"""

    def __init__(self, network: str = 'testnet'):
        self.network = network
        self.api_url = self._get_api_url()
        self.session = requests.Session()
        self.session.timeout = 30

    def _get_api_url(self) -> str:
        """Get API URL for network"""
        urls = {
            'mainnet': 'https://api.hiro.so',
            'testnet': 'https://api.testnet.hiro.so',
            'devnet': 'http://localhost:20443'
        }
        return urls.get(self.network, urls['testnet'])

    def check_api_status(self) -> Dict:
        """Check Hiro API status and network info"""
        try:
            response = self.session.get(f"{self.api_url}/v2/info")
            response.raise_for_status()
            data = response.json()

            return {
                'status': 'online',
                'block_height': data.get('stacks_tip_height', 0),
                'network_id': data.get('network_id', 'unknown'),
                'server_version': data.get('server_version', 'unknown'),
                'tps': data.get('tps', 0)
            }
        except Exception as e:
            return {
                'status': 'offline',
                'error': str(e)
            }

    def get_account_info(self, address: str) -> Optional[Dict]:
        """Get account information"""
        try:
            response = self.session.get(f"{self.api_url}/v2/accounts/{address}")
            response.raise_for_status()
            return response.json()
        except Exception as e:
            print(f"Error getting account info: {e}")
            return None

    def get_transaction_status(self, tx_id: str) -> Optional[Dict]:
        """Get transaction status"""
        try:
            response = self.session.get(f"{self.api_url}/v2/transactions/{tx_id}")
            response.raise_for_status()
            return response.json()
        except Exception as e:
            print(f"Error getting transaction status: {e}")
            return None

    def wait_for_confirmation(self, tx_id: str, timeout: int = 300) -> bool:
        """Wait for transaction confirmation"""
        start_time = time.time()

        while time.time() - start_time < timeout:
            tx_info = self.get_transaction_status(tx_id)
            if tx_info:
                status = tx_info.get('tx_status', '')
                if status == 'success':
                    return True
                elif status == 'error':
                    return False

            time.sleep(5)

        return False

class EnhancedConxianDeployer:
    """Enhanced Conxian deployer with full CLI integration"""

    def __init__(self, config: Dict, verbose: bool = False):
        self.config = config
        self.verbose = verbose
        self.monitor = ConxianHiroMonitor(config.get('NETWORK', 'testnet'))
        self.contract_categories = self._load_contract_categories()

    def _load_contract_categories(self) -> Dict:
        """Load contract categories from configuration"""
        return {
            'core': ['all-traits', 'utils-encoding', 'utils-utils', 'lib-error-codes'],
            'tokens': ['cxd-token', 'cxlp-token', 'cxvg-token', 'cxtr-token', 'cxs-token'],
            'governance': ['governance-token', 'proposal-engine', 'timelock-controller'],
            'dex': ['dex-factory', 'dex-router', 'dex-pool', 'dex-vault', 'fee-manager'],
            'dimensional': ['dim-registry', 'dim-metrics', 'position-nft', 'dimensional-core'],
            'oracle': ['oracle', 'oracle-aggregator', 'btc-adapter'],
            'security': ['circuit-breaker', 'pausable', 'mev-protector'],
            'monitoring': ['analytics-aggregator', 'monitoring-dashboard']
        }

    def run_pre_checks(self) -> bool:
        """Run comprehensive pre-deployment checks"""
        print(f"\n{Fore.CYAN}üîç Running Pre-Deployment Checks{Style.RESET_ALL}\n")

        checks = [
            ('Environment', self._check_environment),
            ('Network', self._check_network),
            ('Compilation', self._check_compilation),
            ('Account Balance', self._check_balance),
            ('Deployment Mode', self._check_deployment_mode)
        ]

        all_passed = True
        for check_name, check_func in checks:
            try:
                if not check_func():
                    all_passed = False
            except Exception as e:
                print(f"‚ùå {check_name} check failed: {e}")
                all_passed = False

        print(f"\n{Fore.GREEN if all_passed else Fore.RED}{'‚úÖ' if all_passed else '‚ùå'} Overall Status: {'READY' if all_passed else 'ISSUES FOUND'}{Style.RESET_ALL}")
        return all_passed

    def _check_environment(self) -> bool:
        """Check environment configuration"""
        print("üîß Checking environment variables...")

        required = ['DEPLOYER_PRIVKEY', 'SYSTEM_ADDRESS', 'NETWORK']
        missing = [req for req in required if not self.config.get(req)]

        if missing:
            print(f"‚ùå Missing required variables: {', '.join(missing)}")
            return False

        print(f"‚úÖ DEPLOYER_PRIVKEY: {self.config['DEPLOYER_PRIVKEY'][:10]}...")
        print(f"‚úÖ SYSTEM_ADDRESS: {self.config['SYSTEM_ADDRESS']}")
        print(f"‚úÖ NETWORK: {self.config['NETWORK']}")
        return True

    def _check_network(self) -> bool:
        """Check network connectivity"""
        print("üåê Checking network connectivity...")

        api_status = self.monitor.check_api_status()
        if api_status['status'] == 'online':
            print(f"‚úÖ Connected to {api_status['network_id']}")
            print(f"‚úÖ Block height: {api_status['block_height']}")
            return True
        else:
            print(f"‚ùå Network check failed: {api_status.get('error', 'Unknown error')}")
            return False

    def _check_compilation(self) -> bool:
        """Check contract compilation"""
        print("‚öôÔ∏è  Checking contract compilation...")

        try:
            result = subprocess.run(['clarinet', 'check'],
                                  capture_output=True, text=True, timeout=60)
            if result.returncode == 0:
                print("‚úÖ All contracts compile successfully")
                return True
            else:
                print("‚ö†Ô∏è  Compilation issues detected (deployment may still work)")
                if self.verbose:
                    print(result.stdout)
                return True
        except Exception as e:
            print(f"‚ö†Ô∏è  Could not run compilation check: {e}")
            return True

    def _check_balance(self) -> bool:
        """Check account balance"""
        print("üí∞ Checking account balance...")

        account_info = self.monitor.get_account_info(self.config['SYSTEM_ADDRESS'])
        if account_info:
            balance = int(account_info.get('balance', 0)) / 1000000  # Convert to STX
            min_balance = 10  # Minimum 10 STX for deployment

            print(f"‚úÖ Current balance: {balance} STX")
            if balance < min_balance:
                print(f"‚ö†Ô∏è  Low balance: {balance} STX (minimum {min_balance} STX recommended)")
                return False
            return True
        else:
            print("‚ùå Could not check balance")
            return False

    def _check_deployment_mode(self) -> bool:
        """Check deployment mode"""
        print("üì¶ Checking deployment mode...")

        account_info = self.monitor.get_account_info(self.config['SYSTEM_ADDRESS'])
        if account_info:
            nonce = account_info.get('nonce', 0)
            if nonce > 0:
                print(f"üîÑ Upgrade mode (nonce: {nonce})")
                self.config['DEPLOYMENT_MODE'] = 'upgrade'
            else:
                print("üÜï Full deployment mode")
                self.config['DEPLOYMENT_MODE'] = 'full'
        else:
            print("‚ÑπÔ∏è  Assuming full deployment mode")
            self.config['DEPLOYMENT_MODE'] = 'full'

        return True

    def deploy_conxian(self, category: Optional[str] = None, dry_run: bool = False) -> Dict:
        """Deploy Conxian contracts with enhanced monitoring"""
        print(f"\n{Fore.CYAN}üöÄ Conxian Protocol Deployment{Style.RESET_ALL}")
        print("=" * 60)

        if dry_run:
            return self._dry_run_deployment(category)

        # Get deployment list
        contracts = self._get_deployment_list(category)

        if not contracts:
            print("‚ùå No contracts found to deploy")
            return {'success': False, 'error': 'No contracts found'}

        print(f"üì¶ Deploying {len(contracts)} contracts in {self.config.get('DEPLOYMENT_MODE', 'full')} mode\n")

        results = {'successful': [], 'failed': [], 'skipped': []}

        # Deploy contracts in dependency order
        for i, contract in enumerate(contracts, 1):
            print(f"\n[{i}/{len(contracts)}] Deploying {contract['name']}...")

            try:
                tx_id = self._deploy_single_contract(contract)
                if tx_id:
                    # Monitor transaction
                    confirmed = self.monitor.wait_for_confirmation(
                        tx_id,
                        int(self.config.get('CONFIRMATION_TIMEOUT', 300))
                    )

                    if confirmed:
                        print(f"‚úÖ {contract['name']} deployed successfully")
                        results['successful'].append({'name': contract['name'], 'tx_id': tx_id})
                    else:
                        print(f"‚è∞ {contract['name']} deployment timed out")
                        results['failed'].append({'name': contract['name'], 'error': 'timeout'})
                else:
                    results['failed'].append({'name': contract['name'], 'error': 'deployment failed'})

            except Exception as e:
                print(f"‚ùå {contract['name']} failed: {e}")
                results['failed'].append({'name': contract['name'], 'error': str(e)})

            # Small delay between deployments
            time.sleep(2)

        # Save deployment results
        self._save_deployment_results(results)

        return results

    def _dry_run_deployment(self, category: Optional[str] = None) -> Dict:
        """Perform dry run of deployment"""
        print(f"\n{Fore.YELLOW}üîç DRY RUN MODE{Style.RESET_ALL}")
        print("=" * 60)

        contracts = self._get_deployment_list(category)
        total_gas = 0

        print("üìã Deployment Plan:\n")

        for i, contract in enumerate(contracts, 1):
            gas_estimate = self._estimate_gas(contract)
            total_gas += gas_estimate

            print(f"{i}. {contract['name']}")
            print(f"   Path: {contract['path']}")
            print(f"   Estimated gas: {gas_estimate} STX")
            print()

        print("üìä Summary:")
        print(f"   Total contracts: {len(contracts)}")
        print(f"   Estimated gas: {total_gas} STX")
        print(f"   Deployment mode: {self.config.get('DEPLOYMENT_MODE', 'full')}")
        print(f"   Network: {self.config.get('NETWORK', 'testnet')}")

        return {'success': True, 'dry_run': True, 'contracts': len(contracts), 'gas_estimate': total_gas}

    def _get_deployment_list(self, category: Optional[str] = None) -> List[Dict]:
        """Get list of contracts to deploy"""
        contracts = []

        # Try Clarinet.toml first
        clarinet_path = Path("Clarinet.toml")
        if clarinet_path.exists():
            contracts = self._parse_clarinet_toml(clarinet_path)
        else:
            # Fallback to directory scan
            contracts = self._scan_contracts_directory()

        # Filter by category if specified
        if category and category in self.contract_categories:
            category_contracts = self.contract_categories[category]
            contracts = [c for c in contracts if any(cat in c['name'] for cat in category_contracts)]

        # Sort by dependency order
        return self._sort_by_dependencies(contracts)

    def _parse_clarinet_toml(self, clarinet_path: Path) -> List[Dict]:
        """Parse contracts from Clarinet.toml"""
        contracts = []

        try:
            with open(clarinet_path, 'r') as f:
                content = f.read()

            # Simple regex to find contract definitions
            import re
            contract_matches = re.findall(r'\[contracts\.([^\]]+)\]\s+path\s*=\s*["\']([^"\']+)["\']', content)

            for contract_name, contract_path in contract_matches:
                full_path = clarinet_path.parent / contract_path
                if full_path.exists():
                    contracts.append({
                        'name': contract_name,
                        'path': contract_path,
                        'full_path': str(full_path)
                    })

        except Exception as e:
            print(f"Warning: Could not parse Clarinet.toml: {e}")

        return contracts

    def _scan_contracts_directory(self) -> List[Dict]:
        """Scan contracts directory for .clar files"""
        contracts = []
        contracts_dir = Path("contracts")

        if contracts_dir.exists():
            for clar_file in contracts_dir.rglob("*.clar"):
                contract_name = clar_file.stem
                contracts.append({
                    'name': contract_name,
                    'path': str(clar_file.relative_to(clarinet_path.parent)),
                    'full_path': str(clar_file)
                })

        return contracts

    def _sort_by_dependencies(self, contracts: List[Dict]) -> List[Dict]:
        """Sort contracts by dependency order"""
        # Define deployment order
        priority_order = [
            'all-traits', 'utils-encoding', 'utils-utils', 'lib-error-codes',
            'cxd-token', 'cxlp-token', 'cxvg-token', 'cxtr-token', 'cxs-token',
            'governance-token', 'proposal-engine', 'timelock-controller',
            'oracle', 'oracle-aggregator', 'btc-adapter',
            'dex-factory', 'dex-router', 'dex-pool', 'dex-vault',
            'dim-registry', 'dim-metrics', 'position-nft', 'dimensional-core'
        ]

        def get_priority(contract):
            name = contract['name']
            for i, priority in enumerate(priority_order):
                if priority in name:
                    return i
            return len(priority_order)  # Low priority for unknown contracts

        return sorted(contracts, key=get_priority)

    def _deploy_single_contract(self, contract: Dict) -> Optional[str]:
        """Deploy a single contract (placeholder - would use Stacks SDK)"""
        # This is a placeholder - in a real implementation, this would use
        # the @stacks/transactions library to create and broadcast deployment transactions

        print(f"üìÑ Deploying {contract['name']}...")

        # Simulate deployment
        time.sleep(1)

        # Generate fake transaction ID for demonstration
        fake_tx_id = "0x" + "1" * 64

        return fake_tx_id

    def _estimate_gas(self, contract: Dict) -> float:
        """Estimate gas cost for contract deployment"""
        # Base estimation - in reality this would be more sophisticated
        base_gas = 1.0  # 1 STX base
        complexity_multiplier = 1.0

        if 'dex' in contract['name']:
            complexity_multiplier = 2.0
        elif 'dimensional' in contract['name']:
            complexity_multiplier = 1.5
        elif 'oracle' in contract['name']:
            complexity_multiplier = 1.3

        return base_gas * complexity_multiplier

    def _save_deployment_results(self, results: Dict):
        """Save deployment results to file"""
        timestamp = datetime.now().isoformat()
        deployment_data = {
            'timestamp': timestamp,
            'network': self.config.get('NETWORK', 'testnet'),
            'deployer': self.config.get('SYSTEM_ADDRESS', ''),
            'results': results,
            'config': {
                'mode': self.config.get('DEPLOYMENT_MODE', 'full'),
                'batch_size': self.config.get('BATCH_SIZE', 5),
                'total_contracts': len(results['successful']) + len(results['failed']) + len(results['skipped'])
            }
        }

        # Save to deployment history
        history_path = Path("deployment") / "history.json"
        history_path.parent.mkdir(exist_ok=True)

        history = []
        if history_path.exists():
            with open(history_path, 'r') as f:
                history = json.load(f)

        history.append(deployment_data)

        with open(history_path, 'w') as f:
            json.dump(history, f, indent=2)

        print(f"üíæ Deployment results saved to {history_path}")

def main():
    """Main CLI function"""
    parser = argparse.ArgumentParser(description='Enhanced Conxian Deployment Tool')
    parser.add_argument('--config', default='.env', help='Configuration file path')
    parser.add_argument('--network', choices=['devnet', 'testnet', 'mainnet'], default='testnet')
    parser.add_argument('--category', choices=['core', 'tokens', 'dex', 'dimensional', 'oracle', 'security', 'monitoring'])
    parser.add_argument('--dry-run', action='store_true', help='Perform dry run')
    parser.add_argument('--verbose', '-v', action='store_true', help='Verbose output')
    parser.add_argument('--batch-size', type=int, default=5, help='Contracts per batch')
    parser.add_argument('--parallel', action='store_true', help='Parallel deployment (experimental)')

    args = parser.parse_args()

    try:
        # Load configuration
        config_manager = EnhancedConfigManager(args.config)
        config = config_manager.load_config()

        # Override network if specified
        if args.network:
            config['NETWORK'] = args.network

        # Validate configuration
        is_valid, errors = config_manager.validate_config()
        if not is_valid:
            print("‚ùå Configuration validation failed:")
            for error in errors:
                print(f"   - {error}")
            return 1

        # Initialize deployer
        deployer = EnhancedConxianDeployer(config, args.verbose)

        # Run pre-checks unless in dry-run mode
        if not args.dry_run:
            if not deployer.run_pre_checks():
                print("\n‚ùå Pre-deployment checks failed. Use --dry-run to continue anyway.")
                return 1

        # Execute deployment
        results = deployer.deploy_conxian(
            category=args.category,
            dry_run=args.dry_run
        )

        if args.dry_run:
            print("\nüîç Dry run completed successfully")
            return 0

        # Show final results
        print("
üìä Final Results:"        print(f"‚úÖ Successful: {len(results['successful'])}")
        print(f"‚ùå Failed: {len(results['failed'])}")
        print(f"‚è≠Ô∏è  Skipped: {len(results['skipped'])}")

        if results['failed']:
            print("
‚ùå Failed contracts:"            for failed in results['failed']:
                print(f"   - {failed['name']}: {failed['error']}")
            return 1

        print("
üéâ Deployment completed successfully!"        print("üí° Use monitoring tools to verify all contracts are active")

        return 0

    except KeyboardInterrupt:
        print("
üõë Deployment cancelled by user"        return 1
    except Exception as e:
        print(f"\n‚ùå Deployment failed: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1

if __name__ == "__main__":
    exit(main())
